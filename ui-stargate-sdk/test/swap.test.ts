// @ts-nocheck
// this is pseudo code only

import {test} from 'vitest';
import {ChainId} from '@layerzerolabs/lz-sdk';
import {Signer} from 'ethers';
import {Provider} from '@ethersproject/abstract-provider';
import {Router__factory} from '../src/evm/contracts';
import {getMessagesBySrcTxHash, Message, MessageStatus} from '@layerzerolabs/scan-client';
import assert from 'assert';
import {isSupportedEvmChainId} from '@layerzerolabs/ui-core';

test.skip('StargateRouter example', async () => {
  // factory for UA specific
  const router = StargateRouterFactory.forChainId(ChainId.ETHEREUM);
  // naive approach (assumes signing inside swap());
  const tx = await router.swap({}); // tx inflight
  const {dstTxHash} = await tx.wait();
  assert(dstTxHash, 'dstTxHash');
});

export namespace LZ {
  export enum MessageStatus {
    INFLIGHT = 'INFLIGHT',
    DELIVERED = 'DELIVERED',
    FAILED = 'FAILED',
  }
  export interface Message {
    srcTxHash: string;
    dstTxhash?: string;
    dstChainId: ChainId;
    srcChainId: ChainId;
    status: MessageStatus;
  }
  // cross chain TX
  export interface Transaction<T = unknown> {
    wait(): Promise<T>;
  }
}

//
export interface StargateRouter {
  swap(input: SwapInput): Promise<SwapTransaction>;
}

// UA specific - only LZ.Transaction in cross chain (A->B)
export class SwapTransaction implements LZ.Transaction<{dstChainId: ChainId; dstTxHash: string}> {
  constructor(public readonly srcChainId: ChainId, public readonly srcTxHash: string) {}
  async wait(): Promise<{dstChainId: ChainId; dstTxHash: string}> {
    const {dstChainId, dstTxHash} = await waitForMessageReceived(this.srcChainId, this.srcTxHash);
    return {dstChainId, dstTxHash};
  }
}

// some input args
export type SwapInput = unknown;

// implementation per
class StargateRouter__EVM implements StargateRouter {
  constructor(
    public readonly address: string,
    public readonly chainId: ChainId,
    public readonly signerOrProvider: Signer | Provider,
  ) {}

  async swap() {
    assert(Signer.isSigner(this.signerOrProvider), 'signer');

    // generated by typechain
    const router = Router__factory.connect(this.address, this.signerOrProvider);

    const response = await router.swap(/* args here */);
    const receipt = await response.wait();
    const srcTxHash = receipt.transactionHash;

    return new SwapTransaction(1, srcTxHash);
  }
}

class StargateRouter__SOL implements StargateRouter {
  constructor(
    public readonly address: string,
    public readonly chainId: ChainId,
    // example from
    // https://docs.tor.us/solana-wallet/api-reference/solana/sign-transaction#signtransaction
    public readonly signTransaction?: (data: unknown) => Promise<unknown>,
    public readonly sendTransaction?: (data: unknown) => Promise<unknown>,
  ) {}

  async swap(input: unknown): Promise<SwapTransaction> {
    // SOL specific mappings
    assert(this.sendTransaction, 'sendTransaction');
    assert(this.signTransaction, 'signTransaction');

    const instruction = SystemProgram.transfer({
      fromPubkey: new PublicKey(publicKeys[0]),
      toPubkey: new PublicKey(publicKeys[1]),
      lamports: 0.1 * LAMPORTS_PER_SOL,
    });

    const transaction = new Transaction({
      recentBlockhash: blockhash,
      feePayer: input.wallet.address,
    });

    const signedTransaction = await this.signTransaction(transaction);

    const srcTxHash = await this.sendTransaction(signedTransaction);

    return new SwapTransaction(this.chainId, srcTxHash as string);
  }
}

class StargateRouterFactory {
  static forChainId(chainId: ChainId): StargateRouter {
    if (isSupportedEvmChainId(chainId)) {
      return new StargateRouter__EVM();
    } else if (isSolanaChainId(chainId)) {
      return new StargateRouter__SOL(chainId);
    }
    throw new Error(`No StargateRouter for ${chainId}`);
  }
}

const sleep = (ms = 1000) => new Promise((resolve) => setTimeout(resolve, ms));

async function waitForMessageReceived<T extends Message & {dstTxHash: string}>(
  srcChainId: ChainId,
  srcTxHash: string,
  pollInterval = 1000,
): Promise<T> {
  while (true) {
    const {messages} = await getMessagesBySrcTxHash(srcChainId, srcTxHash);
    const message = messages[0];
    if (messages.length > 1) {
      throw new Error(`More than one message`);
    } else if (message?.status === MessageStatus.FAILED) {
      throw new Error(`Message failed ${message.dstTxError}`);
    } else if (message?.status === MessageStatus.DELIVERED) {
      return message as T;
    }
    await sleep(pollInterval);
  }
}
